// mknumbermemo generates number memo methods for iolang.
package main

import (
	"os"
	"text/template"
)

type Ints struct {
	Start, End int
	V          []int
}

const hdr = `package iolang


// Code generated by mknumbermemo; DO NOT EDIT


import "math"

`

var genInts = template.Must(template.New("genInts").Parse(`
func (vm *VM) initIntsMemo() {
	vm.intsMemo = []*Number{
{{range .V}}		&Number{Object: *vm.CoreInstance("Number"), Value: {{. -}} },
{{end}}	}
}

func (vm *VM) chkIntsMemo(x float64) *Number {
	z := int32(x)
	if float64(z) == x && {{.Start}} <= z && z <= {{.End}} {
		return vm.intsMemo[z - {{.Start}}]
	}
	return nil
}
`))

var genReals = template.Must(template.New("genReals").Parse(`
type realsMemo struct {
{{range $k, $v := .}}	{{$k}} *Number
{{end -}} }

func (vm *VM) initRealsMemo() {
	vm.realsMemo = &realsMemo{
{{range $k, $v := .}}		{{$k}}: &Number{Object: *vm.CoreInstance("Number"), Value: {{$v -}} },
{{end}}
	}
}

func (vm *VM) chkRealsMemo(x float64) *Number {
	switch x {
{{range $k, $v := .}}	case {{$v}}:
		return vm.realsMemo.{{$k}}
{{end}}
	}
	return nil
}
`))

func main() {
	f, err := os.Create("number_memo.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()
	if _, err := f.WriteString(hdr); err != nil {
		panic(err)
	}
	// Memoize -1..255.
	ints := Ints{
		Start: -1,
		End:   255,
	}
	for i := ints.Start; i <= ints.End; i++ {
		ints.V = append(ints.V, i)
	}
	if err := genInts.Execute(f, ints); err != nil {
		panic(err)
	}
	// Memoize 1/2, 1/3, 1/4, all mathematical constants defined in package
	// math, +/- inf, and float/int extrema.
	reals := map[string]string{
		"half":       "0.5",
		"third":      "0.33333333333333333",
		"fourth":     "0.25",
		"e":          "math.E",
		"pi":         "math.Pi",
		"phi":        "math.Phi",
		"sqrt2":      "math.Sqrt2",
		"sqrtE":      "math.SqrtE",
		"sqrtPi":     "math.SqrtPi",
		"sqrtPhi":    "math.SqrtPhi",
		"ln2":        "math.Ln2",
		"log2e":      "math.Log2E",
		"ln10":       "math.Ln10",
		"log10e":     "math.Log10E",
		"eps":        "math.SmallestNonzeroFloat64",
		"maxFloat64": "math.MaxFloat64",
		"minInt16":   "math.MinInt16",
		"maxInt16":   "math.MaxInt16",
		"minInt64":   "math.MinInt64",
		"maxInt64":   "math.MaxInt64",
		"inf":        "math.Inf(1)",
		"ninf":       "math.Inf(-1)",
	}
	if err := genReals.Execute(f, reals); err != nil {
		panic(err)
	}
}
